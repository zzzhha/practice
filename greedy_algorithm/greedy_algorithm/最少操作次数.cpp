#include<iostream>
#include<algorithm>
using namespace std;


//给出两个整数a,b，每次操作可以把a变成a+1 或 a*k 。求把a变成b至少需要几步操作。
//int main() {
//	unsigned long long a, b, k;
//	long long count=0;
//	cin >> a >> b >> k;
//	if (k == 1 || k==0)//如果k==0或者k==1，在b比a大的情况下，只有进行加法操作才能得到相应数据
//	//因此操作次数为b-a次
//	{
//		if (b == 0 && k==0)
//		{
//			count = 1;//特别的，当b k都等于0的时候，那么只用进行1次
//		}
//		cout << b - a;
//		return 0;
//	}
//	//此时，我们把k理解成k进制，把ab看做k进制的数字（以十进制的方式输入）
//	//那么，*k相当于在对应进制末尾加个0（不理解可以参考十进制）
//	//+1就相当于进制最后一位+1
//	//如果我们想从a得到b，最优解法就是：我们就需要把当前的a变成b的前缀
//	//那么我们要加上对应数字的差值，也正因如此，计算机不好判断当前数字是第几位
//	//这里我们选择倒序，当b变成a
//	//b变成a就需要把进制末尾数先变成0，在除对应进制k
//	// 操作次数就为 b%k +1，此处的加1相当于 b/k;
//	//如果a*k大于了b，就相当于b/k<a，说明此时a，b数字位数相同
//	//所需操作次数只用b-a就可以了（相当于a加上b-a次1）
//	//也就是if else的来源
//	while (1) {
//		if (a * k <= b) {
//			count += 1 + b % k;
//			b /= k;
//		}
//		else
//		{
//			count += (b - a);
//			break;
//		}
//	}
//	cout << count;
//	return 0;
//}