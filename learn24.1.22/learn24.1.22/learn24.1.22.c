#define  _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//int main()
//{
//	int a = 0;
//	printf("%d",!a);
//	return 0;
//}
//int main()
//{
//	int num = 3;
//	int i = 0;
//	int count = 0;//计数
//	while (num)
//	{
//		count++;
//		num = num & (num - 1);
//	}
//	printf("%d", count);
//	return 0;
//}
//int main()//求i中补码有几个1
//{
//	int i,j,count=0;
//	scanf("%d", &i);
//	for (j = 0; j < 32; j++)//按位与和右移操作符的算法
//     //i为你所求的数，j为右移操作符移动几位的数，
//	//按位与有零为零，双一为一，因为1前31位都为0，只有最后一位为1
//	//所以按位与前31位全为0，我们只用考虑最后一位为什么，如果所求数
//	//最后一位为1则“所求数&1=1”，所求数就有一个1，用count计数，
//	//再利用右移操作符依次排查1-31位数是否为1，即可求出答案。
//	//可计算负数
//	{
//		if (1 == ((i >> j) & 1))
//		{
//			count++;
//		}
//	}
//	printf("%d", count);
//	return 0;
//}
//int main()//求i中补码有几个1
//{
//	int i = 5;
//	int count=0;
//	while (i)//短除法，计算一个二进制数的方法
// //只能算正数不能算负数。
//	{
//		if (i % 2 == 1)
//			count++;
//		i = i / 2;
//	}
//	printf("%d",count);
//	return 0;
//}
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a ^ b;//=6按位异或
//	//a 00000000000000000000000000000011
//	//b 00000000000000000000000000000101
//    //c 00000000000000000000000000000110
//	//按位异或 对应二进制位相同为0，不同为1
//	return 0;
//}
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a | b;//=7按位或
//	//a 00000000000000000000000000000011
//	//b 00000000000000000000000000000101
//	//c 00000000000000000000000000000111
//	//按位或只要有一个1就为1，两个0才为0，用补码操作
//	return 0;
//}
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int c = a & b;//=1按位与
//	//a 00000000000000000000000000000011
//	//b 00000000000000000000000000000101
//	//c 00000000000000000000000000000001
//	//按位与只要有一个0就为0，两个1才为1，用补码进行操作。
//	return 0;
//}
//int main()
//{
//	int a = 5;
//	int b = a << 1;//左移操作符
//	//a为00000000000000000000000000000101
//	//b为00000000000000000000000000001010
//	//左移操作符整体向左移一位，左边多出的丢弃，右边少的补0
//	return 0;
//}
//int main()
//{
//	int a = 16;
//	//>>  --右移操作符
//	//移动的是二进制位。
//	//a的二进制位00000000000000000000000000100000（32位）
//	//正数原符号位为0，负数为1
//	//b一般为10000000000000000000000000010000（32位）
//	//原理是整体右移一格，最左边空出的一位数写原数字的符号位（1or0），最右边多出一位舍去。
//	//整数的二进制表示有原码，反码，补码
//  //储存到内存的是补码，printf打印的是原码，
//  //正整数原反补码相同。
//  //移位移的是补码，
//  //如  10000000000000000000000000000001--原码
//  //反码11111111111111111111111111111110--反码（符号位不变，其他位置按位取反）
//  //补码11111111111111111111111111111111--补码（反码+1为补码）
// int b=a >> 1;
//	return 0;
//}
////void buttle_sort(int arr[],int sz)
//{
//	//确定冒泡排序的趟数
//	int i=0;
//	for (i = 0; i <sz-1; i++)
//	{
//		int flag = 1;//假设这一趟要排序的数据已经有序
//		int j;
//		for(j=0;j<sz-1-i;j++)//每一趟的冒泡排序
//		{ 
//			if (arr[j] > arr[j + 1])
//			{
//				int tmp = arr[j];
//				arr[j] = arr[j + 1];
//				arr[j + 1] = tmp;
//				flag = 0;//本趟排序的数据其实不完全有序。
//			}
//		}
//		if (flag == 1)
//		{
//			break;//只要第二个for循环调换了一次weizhi ，则flag就会等于0，	
//			//此if条件不成立，再进行大的for循环，如果有一次第二个for循环没有调换顺序
//		    //则可以判定次数列已经有序，flag等于1，直接跳出循环，节省部分时间。
//		}   
//	}
//
//
//}
//int main()
//{
//	int arr[] = { 9,8,7,6,5,4,3,2,1,0 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//对arr进行排序，排成顺序。
//	buttle_sort(arr,sz);//冒泡排序:相邻两个元素比较,较大的放后面.
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}