#include<iostream>
#include<cmath>

using namespace std;

//洛谷P1433 难！！！！！

//贪心  有问题 未知
//int map[20][2];
//int flag[20];
//double tanxin_eat(int x,int y,int n) {//40昏 不知道哪有问题
//	double sum=0;
//	for(int j=0;j<n;j++)
//	{ 
//		double temp = 0;
//		double minn = 205;
//		int t = 0;
//		for (int i = 0; i < n; i++) {
//			if (flag[i])
//				continue;
//			temp = sqrt(pow(x - map[i][0], 2) + pow(y - map[i][1], 2));
//			if (temp< minn)
//			{
//				t = i;
//				minn = temp;
//			}
//		}
//		x = map[t][0];
//		y = map[t][1];
//		flag[t] = 1;
//		sum += minn;
//	}
//	return sum;
//	
//
//}
//int main() {
//	int n;
//	cin >> n;
//	for (int i = 0; i < n; i++) {
//		int x, y;
//		cin >> x >> y;
//		map[i][0] = x;
//		map[i][1] = y;
//	}
//	//printf("%.2lf",tanxin_eat(0, 0, n));
//
//	return 0;
//}


//排列型枚举型问题树
#define MASK(n) ((1 << (n + 1)) - 2)
double x[20], y[20];//记录奶酪下标
int n_nai;//多少块奶酪
double ans = 1e9;//存储答案，值为随便放的一个特别大的值
double dis_nai[20][20];//存储老鼠和每一块奶酪之间的距离和每一块奶酪与奶酪之间的距离
double dp[70000][20] = { 0 };//状态码值，因为n<=15 根据路径压缩 用一个整形来代替数组状态，
//所以2^16=65536 此处用70000可以包括所有的状态码，第二个数值代表哪一个奶酪，存储的值为总距离
//也就是说他存储的是dp[当前状态码][第几块奶酪]=总距离
//                    (下标为：当前状态码所对应的这块奶酪，值为：到此状态码和此块奶酪的时候小鼠已经走过的距离)
//ps：别看他存储的那么大，其实用到的只有2^0到2^15次所对应的15个值，下面那个ind也是

int ind[70000];//状态码所对应的下标
#define S(a) ((a)*(a))//计算平方
double __dis(int i, int j) {
	return sqrt(S(x[i] - x[j]) + S((y[i] - y[j])));//计算两点之间距离
}

void dfs_eat(int t, int now, double s) {
	if (t == 0) {//t==0说明此时掩码值的二进制的每一位都被遍历过了，
		if (s < ans) ans = s;//记录这个递归所用距离，当所有递归都结束的时候，ans会保留最小值，也就是最短距离
		return;
	}
	for (int k = t; k; k -= (-k & k)) {//令k等于当前掩码值，遍历当前掩码值所有的1的个数
		int to = ind[k & -k], next_t = t - (1 << to);//to通过ind获取掩码值最后一位1的对应下标（这个下标对应第几块奶酪）
		//next_t获取当前掩码值减去了最后那位1的所对应的值

		
		//搜索过程剪枝1
		//如果dp存储的最短距离小于此时的最短距离，说明dp存储的那条递归路径更优，所以此条路径被优化
		//如果是等于那么一样可以进行优化，因为我们只要比他好的答案，不要和他一样的答案
		//关于等于优化的疑问：如果dp记录的路径假设才刚刚开始，而本次递归进行的路径快要结束，
		//他俩值虽然相同但是一个刚开始一个快结束，为什么能进行替换
		//9.16刚学注释：能进行等于优化 个人认为 掩码值相同就说明此时他们所对应的掩码值的剩余的“1”个数相同
		//说明不可能一个刚开始一个快结束，因为对应掩码值相同，所以对应的to值一定相同
		//dp保留了 此掩码值所经过路程到下一块奶酪的路程的最优解，你没有比我现在的最优解好
		//那么在经过的奶酪相同的情况下，此路径与dp保留的最优解路径相同，等价于数组for循环遍历，遍历到了两个最小值，我们保留前面那个最小值就好了
		//所以我们可以将此条路径优化
		//换句话说，掩码值确定了已经经过的路程相同，dp保留已经经过的路程的最小值，你没有比我小，我就要把你优化。
		double l = s + dis_nai[now][to];
		if (dp[next_t][to] != 0 && dp[next_t][to] <= l)//dis_nai[now][to]代表now点到to点的距离
																//（如果now为0就代表小鼠与奶酪的距离）
																//如果now为其他值则代表小鼠所在的那块奶酪到to那块奶酪的距离
		{	
			continue;
		}
		//如果判断为否，说明此条路径更优(或者是dp对应值为0，没有存储最短距离)，更新dp值
		dp[next_t][to] = l;

		//搜索过程剪枝2
		//如果已存储的最短路径小于了本条路径已走过的距离，说明ans存储的那条路径更优，优化此条路径
		//此处等于比上面那个剪枝的好解释：记录的总路程ans都小于了当前正在进行递归的此条路径，那么此条路径的总路程一定比记录的要大
		//所以直接优化
		//为什么：此条路径还在进行？因为结束了的话机会再最上面的if停下。
		if (ans <= l)continue;
		//上方两个剪枝都为否的话，说明可以保留本条路径，那么就进行下一次递归，下一次递归的掩码值为next_t（本条路径所对应掩码值）
		//小鼠所在位置位当前所计算的奶酪的位置，路成等于以前的s加上本次递归所走的路程
		dfs_eat(next_t, to, l);
	}
}

//int main() {
//	cin >> n_nai;//记录有多少块奶酪
//	x[0] = y[0] = 0;//记录小鼠初始坐标
//	double a, b;
//	for (int i = 1; i <= n_nai; i++) {//记录奶酪坐标
//		cin >> a >> b;
//		x[i] = a, y[i] = b;
//	}
//	for (int i = 0; i <= n_nai; i++) {//记录小鼠和每一块奶酪的距离和每一块奶酪之间的距离
//		for (int j = i; j <= n_nai; j++) {
//			dis_nai[i][j] = dis_nai[j][i]=__dis(i, j);
//		}
//	}
//	for (int k = 1, i = 0; i <= 15; i++, k *= 2)ind[k] = i;//权值到下标的映射
//	dfs_eat(MASK(n_nai), 0, 0);//第一个掩码值，第二个代表小鼠坐标，第三个代表距离总和
//	printf("%.2lf\n", ans);
//	return 0;
//}